/*
* Generated file
*
* Generated from: yang module name: odl-sal-netconf-connector-cfg yang module local name: sal-netconf-connector
* Generated by: org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
* Generated at: Thu Nov 05 12:03:41 PST 2015
*
* Do not modify this file unless it is present under src/main directory
*/
package org.opendaylight.controller.config.yang.md.sal.connector.netconf;
@org.opendaylight.yangtools.yang.binding.annotations.ModuleQName(namespace = "urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf", name = "odl-sal-netconf-connector-cfg", revision = "2013-10-28")

public abstract class AbstractNetconfConnectorModule extends org.opendaylight.controller.config.spi.AbstractModule<AbstractNetconfConnectorModule> implements org.opendaylight.controller.config.yang.md.sal.connector.netconf.NetconfConnectorModuleMXBean {
    private static final org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger(org.opendaylight.controller.config.yang.md.sal.connector.netconf.AbstractNetconfConnectorModule.class);

    //attributes start

    public static final org.opendaylight.controller.config.api.JmxAttribute addressJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Address");
    private org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Host address;

    public static final org.opendaylight.controller.config.api.JmxAttribute tcpOnlyJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("TcpOnly");
    private java.lang.Boolean tcpOnly;

    public static final org.opendaylight.controller.config.api.JmxAttribute maxConnectionAttemptsJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("MaxConnectionAttempts");
    private java.lang.Long maxConnectionAttempts = new java.lang.Long("0");

    public static final org.opendaylight.controller.config.api.JmxAttribute reconnectOnChangedSchemaJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("ReconnectOnChangedSchema");
    private java.lang.Boolean reconnectOnChangedSchema = new java.lang.Boolean("false");

    public static final org.opendaylight.controller.config.api.JmxAttribute bindingRegistryJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("BindingRegistry");
    private javax.management.ObjectName bindingRegistry; // mandatory

    public static final org.opendaylight.controller.config.api.JmxAttribute yangModuleCapabilitiesJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("YangModuleCapabilities");
    private org.opendaylight.controller.config.yang.md.sal.connector.netconf.YangModuleCapabilities yangModuleCapabilities;

    public static final org.opendaylight.controller.config.api.JmxAttribute keepaliveDelayJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("KeepaliveDelay");
    private java.lang.Long keepaliveDelay = new java.lang.Long("120");

    public static final org.opendaylight.controller.config.api.JmxAttribute passwordJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Password");
    private java.lang.String password;

    public static final org.opendaylight.controller.config.api.JmxAttribute eventExecutorJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("EventExecutor");
    private javax.management.ObjectName eventExecutor; // mandatory

    public static final org.opendaylight.controller.config.api.JmxAttribute portJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Port");
    private org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.PortNumber port;

    public static final org.opendaylight.controller.config.api.JmxAttribute connectionTimeoutMillisJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("ConnectionTimeoutMillis");
    private java.lang.Long connectionTimeoutMillis = new java.lang.Long("20000");

    public static final org.opendaylight.controller.config.api.JmxAttribute defaultRequestTimeoutMillisJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("DefaultRequestTimeoutMillis");
    private java.lang.Long defaultRequestTimeoutMillis = new java.lang.Long("60000");

    public static final org.opendaylight.controller.config.api.JmxAttribute processingExecutorJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("ProcessingExecutor");
    private javax.management.ObjectName processingExecutor; // mandatory

    public static final org.opendaylight.controller.config.api.JmxAttribute sleepFactorJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("SleepFactor");
    private java.math.BigDecimal sleepFactor = new java.math.BigDecimal("1.5");

    public static final org.opendaylight.controller.config.api.JmxAttribute clientDispatcherJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("ClientDispatcher");
    private javax.management.ObjectName clientDispatcher; // optional

    public static final org.opendaylight.controller.config.api.JmxAttribute domRegistryJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("DomRegistry");
    private javax.management.ObjectName domRegistry; // mandatory

    public static final org.opendaylight.controller.config.api.JmxAttribute usernameJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Username");
    private java.lang.String username;

    public static final org.opendaylight.controller.config.api.JmxAttribute betweenAttemptsTimeoutMillisJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("BetweenAttemptsTimeoutMillis");
    private java.lang.Integer betweenAttemptsTimeoutMillis = new java.lang.Integer("2000");

    public static final org.opendaylight.controller.config.api.JmxAttribute keepaliveExecutorJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("KeepaliveExecutor");
    private javax.management.ObjectName keepaliveExecutor; // optional

    //attributes end

    public AbstractNetconfConnectorModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier,org.opendaylight.controller.config.api.DependencyResolver dependencyResolver) {
        super(identifier, dependencyResolver);
    }

    public AbstractNetconfConnectorModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier,org.opendaylight.controller.config.api.DependencyResolver dependencyResolver,AbstractNetconfConnectorModule oldModule,java.lang.AutoCloseable oldInstance) {
        super(identifier, dependencyResolver, oldModule, oldInstance);
    }

    @Override
    public void validate() {
        dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.md.sal.binding.BindingAwareBrokerServiceInterface.class, bindingRegistry, bindingRegistryJmxAttribute);
        dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.netty.EventExecutorServiceInterface.class, eventExecutor, eventExecutorJmxAttribute);
        dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.threadpool.ThreadPoolServiceInterface.class, processingExecutor, processingExecutorJmxAttribute);
        if(clientDispatcher != null) {
            dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.config.netconf.NetconfClientDispatcherServiceInterface.class, clientDispatcher, clientDispatcherJmxAttribute);
        }
        dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.md.sal.dom.BrokerServiceInterface.class, domRegistry, domRegistryJmxAttribute);
        if(keepaliveExecutor != null) {
            dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.threadpool.ScheduledThreadPoolServiceInterface.class, keepaliveExecutor, keepaliveExecutorJmxAttribute);
        }

        customValidation();
    }

    protected void customValidation() {
    }

    private org.opendaylight.controller.sal.binding.api.BindingAwareBroker bindingRegistryDependency;
    protected final org.opendaylight.controller.sal.binding.api.BindingAwareBroker getBindingRegistryDependency(){
        return bindingRegistryDependency;
    }private io.netty.util.concurrent.EventExecutor eventExecutorDependency;
    protected final io.netty.util.concurrent.EventExecutor getEventExecutorDependency(){
        return eventExecutorDependency;
    }private org.opendaylight.controller.config.threadpool.ThreadPool processingExecutorDependency;
    protected final org.opendaylight.controller.config.threadpool.ThreadPool getProcessingExecutorDependency(){
        return processingExecutorDependency;
    }private org.opendaylight.controller.netconf.client.NetconfClientDispatcher clientDispatcherDependency;
    protected final org.opendaylight.controller.netconf.client.NetconfClientDispatcher getClientDispatcherDependency(){
        return clientDispatcherDependency;
    }private org.opendaylight.controller.sal.core.api.Broker domRegistryDependency;
    protected final org.opendaylight.controller.sal.core.api.Broker getDomRegistryDependency(){
        return domRegistryDependency;
    }private org.opendaylight.controller.config.threadpool.ScheduledThreadPool keepaliveExecutorDependency;
    protected final org.opendaylight.controller.config.threadpool.ScheduledThreadPool getKeepaliveExecutorDependency(){
        return keepaliveExecutorDependency;
    }

    protected final void resolveDependencies() {
        processingExecutorDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.config.threadpool.ThreadPool.class, processingExecutor, processingExecutorJmxAttribute);
        bindingRegistryDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.sal.binding.api.BindingAwareBroker.class, bindingRegistry, bindingRegistryJmxAttribute);
        domRegistryDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.sal.core.api.Broker.class, domRegistry, domRegistryJmxAttribute);
        if (clientDispatcher!=null) {
            clientDispatcherDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.netconf.client.NetconfClientDispatcher.class, clientDispatcher, clientDispatcherJmxAttribute);
        }
        if (keepaliveExecutor!=null) {
            keepaliveExecutorDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.config.threadpool.ScheduledThreadPool.class, keepaliveExecutor, keepaliveExecutorJmxAttribute);
        }
        eventExecutorDependency = dependencyResolver.resolveInstance(io.netty.util.concurrent.EventExecutor.class, eventExecutor, eventExecutorJmxAttribute);
        if (yangModuleCapabilities!=null){
            yangModuleCapabilities.injectDependencyResolver(dependencyResolver);
        }
    }

    public boolean canReuseInstance(AbstractNetconfConnectorModule oldModule){
        // allow reusing of old instance if no parameters was changed
        return isSame(oldModule);
    }

    public java.lang.AutoCloseable reuseInstance(java.lang.AutoCloseable oldInstance){
        // implement if instance reuse should be supported. Override canReuseInstance to change the criteria.
        return oldInstance;
    }

    public boolean isSame(AbstractNetconfConnectorModule other) {
        if (other == null) {
            throw new IllegalArgumentException("Parameter 'other' is null");
        }
        if (java.util.Objects.deepEquals(address, other.address) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(tcpOnly, other.tcpOnly) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(maxConnectionAttempts, other.maxConnectionAttempts) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(reconnectOnChangedSchema, other.reconnectOnChangedSchema) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(bindingRegistry, other.bindingRegistry) == false) {
            return false;
        }
        if(bindingRegistry!= null) {
            if (!dependencyResolver.canReuseDependency(bindingRegistry, bindingRegistryJmxAttribute)) { // reference to dependency must be reusable as well
                return false;
            }
        }
        if (java.util.Objects.deepEquals(yangModuleCapabilities, other.yangModuleCapabilities) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(keepaliveDelay, other.keepaliveDelay) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(password, other.password) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(eventExecutor, other.eventExecutor) == false) {
            return false;
        }
        if(eventExecutor!= null) {
            if (!dependencyResolver.canReuseDependency(eventExecutor, eventExecutorJmxAttribute)) { // reference to dependency must be reusable as well
                return false;
            }
        }
        if (java.util.Objects.deepEquals(port, other.port) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(connectionTimeoutMillis, other.connectionTimeoutMillis) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(defaultRequestTimeoutMillis, other.defaultRequestTimeoutMillis) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(processingExecutor, other.processingExecutor) == false) {
            return false;
        }
        if(processingExecutor!= null) {
            if (!dependencyResolver.canReuseDependency(processingExecutor, processingExecutorJmxAttribute)) { // reference to dependency must be reusable as well
                return false;
            }
        }
        if (java.util.Objects.deepEquals(sleepFactor, other.sleepFactor) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(clientDispatcher, other.clientDispatcher) == false) {
            return false;
        }
        if(clientDispatcher!= null) {
            if (!dependencyResolver.canReuseDependency(clientDispatcher, clientDispatcherJmxAttribute)) { // reference to dependency must be reusable as well
                return false;
            }
        }
        if (java.util.Objects.deepEquals(domRegistry, other.domRegistry) == false) {
            return false;
        }
        if(domRegistry!= null) {
            if (!dependencyResolver.canReuseDependency(domRegistry, domRegistryJmxAttribute)) { // reference to dependency must be reusable as well
                return false;
            }
        }
        if (java.util.Objects.deepEquals(username, other.username) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(betweenAttemptsTimeoutMillis, other.betweenAttemptsTimeoutMillis) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(keepaliveExecutor, other.keepaliveExecutor) == false) {
            return false;
        }
        if(keepaliveExecutor!= null) {
            if (!dependencyResolver.canReuseDependency(keepaliveExecutor, keepaliveExecutorJmxAttribute)) { // reference to dependency must be reusable as well
                return false;
            }
        }

        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AbstractNetconfConnectorModule that = (AbstractNetconfConnectorModule) o;
        return identifier.equals(that.identifier);
    }

    @Override
    public int hashCode() {
        return identifier.hashCode();
    }

    // getters and setters
    @Override
    public org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Host getAddress() {
        return address;
    }

    @Override
    public void setAddress(org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Host address) {
        this.address = address;
    }

    @Override
    public java.lang.Boolean getTcpOnly() {
        return tcpOnly;
    }

    @Override
    public void setTcpOnly(java.lang.Boolean tcpOnly) {
        this.tcpOnly = tcpOnly;
    }

    @Override
    public java.lang.Long getMaxConnectionAttempts() {
        return maxConnectionAttempts;
    }

    /**
    * Maximum number of connection retries. Non positive value or null is interpreted as infinity.
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Maximum number of connection retries. Non positive value or null is interpreted as infinity.")
    public void setMaxConnectionAttempts(java.lang.Long maxConnectionAttempts) {
        this.maxConnectionAttempts = maxConnectionAttempts;
    }

    @Override
    public java.lang.Boolean getReconnectOnChangedSchema() {
        return reconnectOnChangedSchema;
    }

    /**
    * If true, the connector would auto disconnect/reconnect when schemas are changed in the remote device.
    *                              The connector subscribes (right after connect) to base netconf notifications and listens for netconf-capability-change notification
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "If true, the connector would auto disconnect/reconnect when schemas are changed in the remote device. The connector subscribes (right after connect) to base netconf notifications and listens for netconf-capability-change notification")
    public void setReconnectOnChangedSchema(java.lang.Boolean reconnectOnChangedSchema) {
        this.reconnectOnChangedSchema = reconnectOnChangedSchema;
    }

    @Override
    public javax.management.ObjectName getBindingRegistry() {
        return bindingRegistry;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.md.sal.binding.BindingAwareBrokerServiceInterface.class)
    public void setBindingRegistry(javax.management.ObjectName bindingRegistry) {
        this.bindingRegistry = bindingRegistry;
    }

    @Override
    public org.opendaylight.controller.config.yang.md.sal.connector.netconf.YangModuleCapabilities getYangModuleCapabilities() {
        return yangModuleCapabilities;
    }

    @Override
    public void setYangModuleCapabilities(org.opendaylight.controller.config.yang.md.sal.connector.netconf.YangModuleCapabilities yangModuleCapabilities) {
        this.yangModuleCapabilities = yangModuleCapabilities;
    }

    @Override
    public java.lang.Long getKeepaliveDelay() {
        return keepaliveDelay;
    }

    /**
    * Netconf connector sends keepalive RPCs while the session is idle, this delay specifies the delay between keepalive RPC in seconds
    *                              If a value <1 is provided, no keepalives will be sent
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Netconf connector sends keepalive RPCs while the session is idle, this delay specifies the delay between keepalive RPC in seconds If a value <1 is provided, no keepalives will be sent")
    public void setKeepaliveDelay(java.lang.Long keepaliveDelay) {
        this.keepaliveDelay = keepaliveDelay;
    }

    @Override
    public java.lang.String getPassword() {
        return password;
    }

    @Override
    public void setPassword(java.lang.String password) {
        this.password = password;
    }

    @Override
    public javax.management.ObjectName getEventExecutor() {
        return eventExecutor;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.netty.EventExecutorServiceInterface.class)
    public void setEventExecutor(javax.management.ObjectName eventExecutor) {
        this.eventExecutor = eventExecutor;
    }

    @Override
    public org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.PortNumber getPort() {
        return port;
    }

    @Override
    public void setPort(org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.PortNumber port) {
        this.port = port;
    }

    @Override
    public java.lang.Long getConnectionTimeoutMillis() {
        return connectionTimeoutMillis;
    }

    /**
    * Specifies timeout in milliseconds after which connection must be established.
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Specifies timeout in milliseconds after which connection must be established.")
    public void setConnectionTimeoutMillis(java.lang.Long connectionTimeoutMillis) {
        this.connectionTimeoutMillis = connectionTimeoutMillis;
    }

    @Override
    public java.lang.Long getDefaultRequestTimeoutMillis() {
        return defaultRequestTimeoutMillis;
    }

    /**
    * Timeout for blocking operations within transactions.
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Timeout for blocking operations within transactions.")
    public void setDefaultRequestTimeoutMillis(java.lang.Long defaultRequestTimeoutMillis) {
        this.defaultRequestTimeoutMillis = defaultRequestTimeoutMillis;
    }

    @Override
    public javax.management.ObjectName getProcessingExecutor() {
        return processingExecutor;
    }

    /**
    * Makes up for flaws in netty threading design
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.threadpool.ThreadPoolServiceInterface.class)
    @org.opendaylight.controller.config.api.annotations.Description(value = "Makes up for flaws in netty threading design")
    public void setProcessingExecutor(javax.management.ObjectName processingExecutor) {
        this.processingExecutor = processingExecutor;
    }

    @Override
    public java.math.BigDecimal getSleepFactor() {
        return sleepFactor;
    }

    @Override
    public void setSleepFactor(java.math.BigDecimal sleepFactor) {
        this.sleepFactor = sleepFactor;
    }

    @Override
    public javax.management.ObjectName getClientDispatcher() {
        return clientDispatcher;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.config.netconf.NetconfClientDispatcherServiceInterface.class)
    public void setClientDispatcher(javax.management.ObjectName clientDispatcher) {
        this.clientDispatcher = clientDispatcher;
    }

    @Override
    public javax.management.ObjectName getDomRegistry() {
        return domRegistry;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.md.sal.dom.BrokerServiceInterface.class)
    public void setDomRegistry(javax.management.ObjectName domRegistry) {
        this.domRegistry = domRegistry;
    }

    @Override
    public java.lang.String getUsername() {
        return username;
    }

    @Override
    public void setUsername(java.lang.String username) {
        this.username = username;
    }

    @Override
    public java.lang.Integer getBetweenAttemptsTimeoutMillis() {
        return betweenAttemptsTimeoutMillis;
    }

    /**
    * Initial timeout in milliseconds to wait between connection attempts. Will be multiplied by sleep-factor with every additional attempt
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Initial timeout in milliseconds to wait between connection attempts. Will be multiplied by sleep-factor with every additional attempt")
    public void setBetweenAttemptsTimeoutMillis(java.lang.Integer betweenAttemptsTimeoutMillis) {
        this.betweenAttemptsTimeoutMillis = betweenAttemptsTimeoutMillis;
    }

    @Override
    public javax.management.ObjectName getKeepaliveExecutor() {
        return keepaliveExecutor;
    }

    /**
    * Dedicated solely to keepalive execution
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.threadpool.ScheduledThreadPoolServiceInterface.class)
    @org.opendaylight.controller.config.api.annotations.Description(value = "Dedicated solely to keepalive execution")
    public void setKeepaliveExecutor(javax.management.ObjectName keepaliveExecutor) {
        this.keepaliveExecutor = keepaliveExecutor;
    }

    public org.slf4j.Logger getLogger() {
        return LOGGER;
    }

}
